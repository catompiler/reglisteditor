#include "reglistcoexporter.h"
#include <algorithm>
#include <QFile>
#include <QFileInfo>
#include <QDir>
#include <QIODevice>
#include <QTextStream>
#include <QSet>
#include "regentry.h"
#include "regvar.h"
#include "regtypes.h"
#include "regutils.h"
#include <QDebug>


#define DEBUG_OUTPUT 1


RegListCoExporter::RegListCoExporter(QObject *parent)
    : RegListExporter{parent}
{
}

RegListCoExporter::~RegListCoExporter()
{
}


bool RegListCoExporter::doExport(const QString& filename, const RegEntryList* regentrylist)
{
    QFileInfo fi(filename);
    QDir dir = fi.dir();

    QString baseName = fi.baseName();
    QString co_name_c = baseName + ".c";
    QString co_name_h = baseName + ".h";

    if(m_dataName.isEmpty()) m_dataName = baseName;

    QString co_filename_c = dir.filePath(co_name_c);
    QString co_filename_h = dir.filePath(co_name_h);

    if(!exportCoH(co_filename_h, regentrylist)) return false;
    if(!exportCoC(co_filename_c, regentrylist)) return false;

    return true;
}

bool RegListCoExporter::exportCoH(const QString& filename, const RegEntryList* regentrylist)
{
    QFile file(filename);

    if(!file.open(QIODevice::WriteOnly)) return false;

    QFileInfo fileinfo(file);

#if defined(DEBUG_OUTPUT) && DEBUG_OUTPUT == 1
    QDebug out = qDebug();
#else
    QTextStream out(&file);
#endif

    QString co_h_name = fileinfo.fileName().replace(QChar('.'), QChar('_'));
    QString header_guard_name = co_h_name.toUpper();

    // header
    out << "#ifndef " << header_guard_name << "\n"
        << "#define " << header_guard_name << "\n"
        << "\n\n"
        << "// THIS FILE IS GENERATED AUTOMATICALLY!\n"
        << "// DO NOT EDIT THIS FILE!\n"
        << "\n\n";

    bool res = true;

    res &= writeCOCounters(file, regentrylist);
    res &= writeCOArraySizes(file, regentrylist);
    res &= writeCOexternOd(file);
    res &= writeCOShortcuts(file, regentrylist);
    res &= writeCOShortcutsWithNames(file, regentrylist);

    // footer
    out << "\n#endif /* " << header_guard_name << " */\n";

    // Files closed in dtors, but, i want to do it manually.
    file.close();

    return res;
}

bool RegListCoExporter::writeCOCounters(QFile& file, const RegEntryList* regentrylist)
{
#if defined(DEBUG_OUTPUT) && DEBUG_OUTPUT == 1
    Q_UNUSED(file)
    QDebug out = qDebug();
#else
    QTextStream out(&file);
#endif

    QMap<uint, QPair<uint, QString>> cnts;

    cnts[RegEFlag::CON_CNT_NMT] = qMakePair(0, QStringLiteral("OD_CNT_NMT"));
    cnts[RegEFlag::CON_CNT_EM] = qMakePair(0, QStringLiteral("OD_CNT_EM"));
    cnts[RegEFlag::CON_CNT_SYNC] = qMakePair(0, QStringLiteral("OD_CNT_SYNC"));
    cnts[RegEFlag::CON_CNT_SYNC_PROD] = qMakePair(0, QStringLiteral("OD_CNT_SYNC_PROD"));
    cnts[RegEFlag::CON_CNT_STORAGE] = qMakePair(0, QStringLiteral("OD_CNT_STORAGE"));
    cnts[RegEFlag::CON_CNT_TIME] = qMakePair(0, QStringLiteral("OD_CNT_TIME"));
    cnts[RegEFlag::CON_CNT_EM_PROD] = qMakePair(0, QStringLiteral("OD_CNT_EM_PROD"));
    cnts[RegEFlag::CON_CNT_HB_CONS] = qMakePair(0, QStringLiteral("OD_CNT_HB_CONS"));
    cnts[RegEFlag::CON_CNT_HB_PROD] = qMakePair(0, QStringLiteral("OD_CNT_HB_PROD"));
    cnts[RegEFlag::CON_CNT_SDO_SRV] = qMakePair(0, QStringLiteral("OD_CNT_SDO_SRV"));
    cnts[RegEFlag::CON_CNT_SDO_CLI] = qMakePair(0, QStringLiteral("OD_CNT_SDO_CLI"));
    cnts[RegEFlag::CON_CNT_RPDO] = qMakePair(0, QStringLiteral("OD_CNT_RPDO"));
    cnts[RegEFlag::CON_CNT_TPDO] = qMakePair(0, QStringLiteral("OD_CNT_TPDO"));

    for(auto reit = regentrylist->cbegin(); reit != regentrylist->cend(); ++ reit){
        const RegEntry* re = *reit;

        for(auto rvit = re->cbegin(); rvit != re->cend(); ++ rvit){
            const RegVar* rv = *rvit;

            for(auto it = cnts.begin(); it != cnts.end(); ++ it){
                if(rv->eflags() & it.key()){
                    it.value().first ++;
                }
            }
        }
    }

    out << "// Counters of OD objects\n";

    for(auto it = cnts.begin(); it != cnts.end(); ++ it){
        out << QStringLiteral("#define %1 %2")
               .arg(it.value().second)
               .arg(it.value().first)
            << "\n";
    }

    out << "\n\n";

    return true;
}

bool RegListCoExporter::writeCOArraySizes(QFile& file, const RegEntryList* regentrylist)
{
#if defined(DEBUG_OUTPUT) && DEBUG_OUTPUT == 1
    Q_UNUSED(file)
    QDebug out = qDebug();
#else
    QTextStream out(&file);
#endif

    out << "// Sizes of OD arrays\n";

    for(auto reit = regentrylist->cbegin(); reit != regentrylist->cend(); ++ reit){
        const RegEntry* re = *reit;

        if(re->type() == ObjectType::ARR){

            uint size = 0;

            for(auto rvit = re->cbegin(); rvit != re->cend(); ++ rvit){
                const RegVar* rv = *rvit;
                if((rv->eflags() & RegEFlag::CO_COUNT) == 0){
                    size = qMax(rv->count(), size);
                }
            }

            out << QStringLiteral("#define OD_CNT_ARR_%1 %2")
                   .arg(static_cast<uint>(re->index()), 0, 16)
                   .arg(size)
                << "\n";
        }
    }

    out << "\n\n";

    return true;
}

bool RegListCoExporter::writeCOexternOd(QFile& file)
{
#if defined(DEBUG_OUTPUT) && DEBUG_OUTPUT == 1
    Q_UNUSED(file)
    QDebug out = qDebug();
#else
    QTextStream out(&file);
#endif

    out << "#ifndef OD_ATTR_OD\n"
        << "#define OD_ATTR_OD\n"
        << "#endif\n"
        << "extern OD_ATTR_OD OD_t *OD;\n";

    out << "\n\n";

    return true;
}

bool RegListCoExporter::writeCOShortcuts(QFile& file, const RegEntryList* regentrylist)
{
#if defined(DEBUG_OUTPUT) && DEBUG_OUTPUT == 1
    Q_UNUSED(file)
    QDebug out = qDebug();
#else
    QTextStream out(&file);
#endif

    out << "// Object dictionary entries - shortcuts\n";

    uint list_index = 0;

    for(auto reit = regentrylist->cbegin(); reit != regentrylist->cend(); ++ reit){
        const RegEntry* re = *reit;

        out << QStringLiteral("#define OD_ENTRY_H%1 &OD->list[%2]")
               .arg(static_cast<uint>(re->index()), 0, 16)
               .arg(list_index)
            << "\n";
    }

    out << "\n\n";

    return true;
}

bool RegListCoExporter::writeCOShortcutsWithNames(QFile& file, const RegEntryList* regentrylist)
{
#if defined(DEBUG_OUTPUT) && DEBUG_OUTPUT == 1
    Q_UNUSED(file)
    QDebug out = qDebug();
#else
    QTextStream out(&file);
#endif

    out << "// Object dictionary entries - shortcuts with names\n";

    uint list_index = 0;

    for(auto reit = regentrylist->cbegin(); reit != regentrylist->cend(); ++ reit){
        const RegEntry* re = *reit;

        out << QStringLiteral("#define OD_ENTRY_H%1_%2 &OD->list[%3]")
               .arg(static_cast<uint>(re->index()), 0, 16)
               .arg(RegUtils::makeName(re->name(), m_syntaxType))
               .arg(list_index)
            << "\n";
    }

    out << "\n\n";

    return true;
}

bool RegListCoExporter::exportCoC(const QString& filename, const RegEntryList* regentrylist)
{
    QFile file(filename);

    if(!file.open(QIODevice::WriteOnly)) return false;

    QFileInfo fileinfo(file);

#if defined(DEBUG_OUTPUT) && DEBUG_OUTPUT == 1
    Q_UNUSED(file)
    QDebug out = qDebug();
#else
    QTextStream out(&file);
#endif

    QString co_h_name = fileinfo.fileName().replace(".c", ".h");

    // header
    out << QStringLiteral("#include \"%1\"\n").arg(co_h_name)
        << "\n\n"
        << "#define OD_DEFINITION\n"
        << "#include \"301/CO_ODinterface.h\"\n"
        << "#include \"OD.h\"\n"
        << "\n"
        << "#if CO_VERSION_MAJOR < 4\n"
        << "#error This Object dictionary is compatible with CANopenNode V4.0 and above!\n"
        << "#endif\n"
        << "\n\n";

    bool res = true;

    res &= writeAllOdObjConstDefs(file, regentrylist);

    // footer

    // Files closed in dtors, but, i want to do it manually.
    file.close();

    return res;
}

bool RegListCoExporter::writeAllOdObjConstDefs(QFile& file, const RegEntryList* regentrylist)
{
#if defined(DEBUG_OUTPUT) && DEBUG_OUTPUT == 1
    Q_UNUSED(file)
    QDebug out = qDebug();
#else
    QTextStream out(&file);
#endif

    out << "// All OD objects (constant definitions)\n";

    out << "typedef struct {\n";

    for(auto reit = regentrylist->cbegin(); reit != regentrylist->cend(); ++ reit){
        const RegEntry* re = *reit;

        out << QStringLiteral("%1 %2;")
               .arg(getOdEntryTypeStr(re->type()), getOdEntryFieldDecl(re))
            << "\n";
    }

    out << "} ODObjs_t;\n\n";

    out << "static CO_PROGMEM ODObjs_t ODObjs = {\n";

    bool firstEntry = true;

    for(auto reit = regentrylist->cbegin(); reit != regentrylist->cend(); ++ reit){
        const RegEntry* re = *reit;

        if(!firstEntry){
            out << ",\n";
        }
        firstEntry = false;

        out << QStringLiteral(".%1 = {")
               .arg(getOdEntryFieldDecl(re))
            << "\n";

        for(auto rvit = re->cbegin(); rvit != re->cend(); ++ rvit){
            const RegVar* rv = *rvit;
        }

        out << "}";
    }

    out << "\n};\n";

    return true;
}

void RegListCoExporter::writeOdObjConstDef(QFile& file, const RegEntry* re) const
{
    switch(re->type()){
    case ObjectType::VAR:
        writeOdVarConstDef(file, re);
        break;
    case ObjectType::ARR:
        writeOdArrConstDef(file, re);
        break;
    case ObjectType::REC:
        writeOdRecConstDef(file, re);
        break;
    }
}

void RegListCoExporter::writeOdVarConstDef(QFile& file, const RegEntry* re) const
{
#if defined(DEBUG_OUTPUT) && DEBUG_OUTPUT == 1
    Q_UNUSED(file)
    QDebug out = qDebug();
#else
    QTextStream out(&file);
#endif

    for(auto rvit = re->cbegin(); rvit != re->cend(); ++ rvit){
        const RegVar* rv = *rvit;
    }
}

void RegListCoExporter::writeOdRecConstDef(QFile& file, const RegEntry* re) const
{
#if defined(DEBUG_OUTPUT) && DEBUG_OUTPUT == 1
    Q_UNUSED(file)
    QDebug out = qDebug();
#else
    QTextStream out(&file);
#endif

    for(auto rvit = re->cbegin(); rvit != re->cend(); ++ rvit){
        const RegVar* rv = *rvit;
    }
}

void RegListCoExporter::writeOdArrConstDef(QFile& file, const RegEntry* re) const
{
#if defined(DEBUG_OUTPUT) && DEBUG_OUTPUT == 1
    Q_UNUSED(file)
    QDebug out = qDebug();
#else
    QTextStream out(&file);
#endif

    for(auto rvit = re->cbegin(); rvit != re->cend(); ++ rvit){
        const RegVar* rv = *rvit;
    }
}
QString RegListCoExporter::getOdEntryTypeStr(ObjectType objType) const
{
    switch(objType){
    case ObjectType::VAR:
        return QStringLiteral("OD_obj_var_t");
    case ObjectType::ARR:
        return QStringLiteral("OD_obj_array_t");
    case ObjectType::REC:
        return QStringLiteral("OD_obj_record_t");
    }
    return QStringLiteral("#error Unknown type!");
}

QString RegListCoExporter::getOdEntryFieldName(const RegEntry* re) const
{
    return QStringLiteral("o_%2_%3")
            .arg(re->index(), 0, 16)
            .arg(RegUtils::getEntryName(re, m_entryNameMap, m_syntaxType));
}

QString RegListCoExporter::getOdEntryFieldDecl(const RegEntry* re) const
{
    QString name = getOdEntryFieldName(re);
    if(re->type() == ObjectType::REC){
        name = QStringLiteral("%1[%2]")
               .arg(name)
               .arg(re->count());
    }
    return name;
}
