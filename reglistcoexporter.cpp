#include "reglistcoexporter.h"
#include <algorithm>
#include <QFile>
#include <QFileInfo>
#include <QDir>
#include <QIODevice>
#include <QTextStream>
#include <QSet>
#include "regentry.h"
#include "regvar.h"
#include "regtypes.h"
#include "regutils.h"
#include <QDebug>


#define DEBUG_OUTPUT 0


RegListCoExporter::RegListCoExporter(QObject *parent)
    : RegListExporter{parent}
{
}

RegListCoExporter::~RegListCoExporter()
{
}


bool RegListCoExporter::doExport(const QString& filepath, const RegEntryList* regentrylist)
{
    QDir path(filepath);
    if(!path.exists()) return false;

    if(m_cohFileName.isEmpty()) m_cohFileName = "OD.h";
    if(m_cocFileName.isEmpty()) m_cocFileName = "OD.c";
    if(m_dataName.isEmpty()) m_dataName = "regs_data";
    if(m_odName.isEmpty()) m_odName = QFileInfo(m_cohFileName).baseName();

    QString cohFileName = QFileInfo(m_cohFileName).isAbsolute() ? m_cohFileName : path.filePath(m_cohFileName);
    QString cocFileName = QFileInfo(m_cocFileName).isAbsolute() ? m_cocFileName : path.filePath(m_cocFileName);

    if(!exportCoH(cohFileName, regentrylist)) return false;
    if(!exportCoC(cocFileName, regentrylist)) return false;

    return true;
}

RegListCoExporter& RegListCoExporter::setCOhFileName(const QString& fileName)
{
    m_cohFileName = fileName;

    return *this;
}

RegListCoExporter& RegListCoExporter::setCOcFileName(const QString& fileName)
{
    m_cocFileName = fileName;

    return *this;
}

RegListCoExporter& RegListCoExporter::setDataFileName(const QString& fileName)
{
    m_dataFileName = fileName;

    return *this;
}

RegListCoExporter& RegListCoExporter::setUserCodeCOh(const QString& userCode)
{
    m_userCodeCOh = userCode;

    return *this;
}

RegListCoExporter& RegListCoExporter::setUserCodeCOc(const QString& userCode)
{
    m_userCodeCOc = userCode;

    return *this;
}

RegListCoExporter& RegListCoExporter::setODName(const QString& odName)
{
    m_odName = odName;

    return *this;
}

bool RegListCoExporter::exportCoH(const QString& filename, const RegEntryList* regentrylist)
{
    QFile file(filename);

    if(!file.open(QIODevice::WriteOnly)) return false;

    QTextStream out_stream(&file);

    QFileInfo fileinfo(file);

#if defined(DEBUG_OUTPUT) && DEBUG_OUTPUT == 1
    QDebug out = qDebug();
#else
    QTextStream& out = out_stream;
#endif

    QString co_h_name = fileinfo.fileName().replace(QChar('.'), QChar('_'));
    QString header_guard_name = co_h_name.toUpper();

    // header
    out << "#ifndef " << header_guard_name << "\n"
        << "#define " << header_guard_name << "\n"
        << "\n\n"
        << "// THIS FILE IS GENERATED AUTOMATICALLY!\n"
        << "// DO NOT EDIT THIS FILE!\n"
        << "\n\n";

    out << "// user code begin\n"
        << m_userCodeCOh
        << "\n// user code end\n\n";

    bool res = true;

    res &= writeCOCounters(out_stream, regentrylist);
    res &= writeCOArraySizes(out_stream, regentrylist);
    res &= writeCOexternOd(out_stream);
    res &= writeCOShortcuts(out_stream, regentrylist);
    res &= writeCOShortcutsWithNames(out_stream, regentrylist);

    // footer
    out << "\n#endif /* " << header_guard_name << " */\n";

    // Files closed in dtors, but, i want to do it manually.
    file.close();

    return res;
}

bool RegListCoExporter::writeCOCounters(QTextStream& out_stream, const RegEntryList* regentrylist)
{
#if defined(DEBUG_OUTPUT) && DEBUG_OUTPUT == 1
    Q_UNUSED(out_stream)
    QDebug out = qDebug();
#else
    QTextStream& out = out_stream;
#endif

    QMap<uint, QPair<uint, QString>> cnts;

    cnts[RegEFlag::CON_CNT_NMT] = qMakePair(0, QStringLiteral("%1_CNT_NMT").arg(m_odName));
    cnts[RegEFlag::CON_CNT_EM] = qMakePair(0, QStringLiteral("%1_CNT_EM").arg(m_odName));
    cnts[RegEFlag::CON_CNT_SYNC] = qMakePair(0, QStringLiteral("%1_CNT_SYNC").arg(m_odName));
    cnts[RegEFlag::CON_CNT_SYNC_PROD] = qMakePair(0, QStringLiteral("%1_CNT_SYNC_PROD").arg(m_odName));
    cnts[RegEFlag::CON_CNT_STORAGE] = qMakePair(0, QStringLiteral("%1_CNT_STORAGE").arg(m_odName));
    cnts[RegEFlag::CON_CNT_TIME] = qMakePair(0, QStringLiteral("%1_CNT_TIME").arg(m_odName));
    cnts[RegEFlag::CON_CNT_EM_PROD] = qMakePair(0, QStringLiteral("%1_CNT_EM_PROD").arg(m_odName));
    cnts[RegEFlag::CON_CNT_HB_CONS] = qMakePair(0, QStringLiteral("%1_CNT_HB_CONS").arg(m_odName));
    cnts[RegEFlag::CON_CNT_HB_PROD] = qMakePair(0, QStringLiteral("%1_CNT_HB_PROD").arg(m_odName));
    cnts[RegEFlag::CON_CNT_SDO_SRV] = qMakePair(0, QStringLiteral("%1_CNT_SDO_SRV").arg(m_odName));
    cnts[RegEFlag::CON_CNT_SDO_CLI] = qMakePair(0, QStringLiteral("%1_CNT_SDO_CLI").arg(m_odName));
    cnts[RegEFlag::CON_CNT_RPDO] = qMakePair(0, QStringLiteral("%1_CNT_RPDO").arg(m_odName));
    cnts[RegEFlag::CON_CNT_TPDO] = qMakePair(0, QStringLiteral("%1_CNT_TPDO").arg(m_odName));

    QMap<uint, uint> cnts_var;
    for(auto it = cnts.begin(); it != cnts.end(); ++ it){
        cnts_var[it.key()] = 0;
    }

    for(auto reit = regentrylist->cbegin(); reit != regentrylist->cend(); ++ reit){
        const RegEntry* re = *reit;

        for(auto rvit = re->cbegin(); rvit != re->cend(); ++ rvit){
            const RegVar* rv = *rvit;

            if(rv->eflags() & RegEFlag::CO_HIDE){
                continue;
            }

            for(auto it = cnts_var.begin(); it != cnts_var.end(); ++ it){
                if(rv->eflags() & it.key()){
                    it.value() ++;
                }
            }
        }

        for(auto it = cnts_var.begin(); it != cnts_var.end(); ++ it){
            if(it.value() != 0) cnts[it.key()].first ++;
            it.value() = 0;
        }
    }

    out << "// Counters of OD objects\n";

    for(auto it = cnts.begin(); it != cnts.end(); ++ it){
        out << QStringLiteral("#define %1 %2")
               .arg(it.value().second)
               .arg(it.value().first)
            << "\n";
    }

    out << "\n\n";

    return true;
}

bool RegListCoExporter::writeCOArraySizes(QTextStream& out_stream, const RegEntryList* regentrylist)
{
#if defined(DEBUG_OUTPUT) && DEBUG_OUTPUT == 1
    Q_UNUSED(out_stream)
    QDebug out = qDebug();
#else
    QTextStream& out = out_stream;
#endif

    out << "// Sizes of OD arrays\n";

    for(auto reit = regentrylist->cbegin(); reit != regentrylist->cend(); ++ reit){
        const RegEntry* re = *reit;

        if(re->type() == ObjectType::ARR){

            if(std::find_if(re->cbegin(), re->cend(), [](const RegVar* rv){
                             return !(rv->eflags() & RegEFlag::CO_HIDE); }) == re->cend()){
                continue;
            }

            uint size = 0;

            for(auto rvit = re->cbegin(); rvit != re->cend(); ++ rvit){
                const RegVar* rv = *rvit;

                if(!(rv->eflags() & RegEFlag::CO_COUNT)){
                    size += rv->count();
                }
            }

            out << QStringLiteral("#define %1_CNT_ARR_%2 %3")
                   .arg(m_odName, QString::number(static_cast<uint>(re->index()), 16).toUpper())
                   .arg(size)
                << "\n";
        }
    }

    out << "\n\n";

    return true;
}

bool RegListCoExporter::writeCOexternOd(QTextStream& out_stream)
{
#if defined(DEBUG_OUTPUT) && DEBUG_OUTPUT == 1
    Q_UNUSED(out_stream)
    QDebug out = qDebug();
#else
    QTextStream& out = out_stream;
#endif

    out << QStringLiteral("#ifndef %1_ATTR_OD\n").arg(m_odName)
        << QStringLiteral("#define %1_ATTR_OD\n").arg(m_odName)
        << QStringLiteral("#endif\n")
        << QStringLiteral("extern %1_ATTR_OD OD_t *%1;\n").arg(m_odName);

    out << "\n\n";

    return true;
}

bool RegListCoExporter::writeCOShortcuts(QTextStream& out_stream, const RegEntryList* regentrylist)
{
#if defined(DEBUG_OUTPUT) && DEBUG_OUTPUT == 1
    Q_UNUSED(out_stream)
    QDebug out = qDebug();
#else
    QTextStream& out = out_stream;
#endif

    out << "// Object dictionary entries - shortcuts\n";

    uint list_index = 0;

    for(auto reit = regentrylist->cbegin(); reit != regentrylist->cend(); ++ reit){
        const RegEntry* re = *reit;

        if(std::find_if(re->cbegin(), re->cend(), [](const RegVar* rv){
                         return !(rv->eflags() & RegEFlag::CO_HIDE); }) == re->cend()){
            continue;
        }

        out << QStringLiteral("#define %1_ENTRY_H%2 &%1->list[%3]")
               .arg(m_odName, QString::number(static_cast<uint>(re->index()), 16).toUpper())
               .arg(list_index)
            << "\n";

        list_index ++;
    }

    out << "\n\n";

    return true;
}

bool RegListCoExporter::writeCOShortcutsWithNames(QTextStream& out_stream, const RegEntryList* regentrylist)
{
#if defined(DEBUG_OUTPUT) && DEBUG_OUTPUT == 1
    Q_UNUSED(out_stream)
    QDebug out = qDebug();
#else
    QTextStream& out = out_stream;
#endif

    out << "// Object dictionary entries - shortcuts with names\n";

    uint list_index = 0;

    for(auto reit = regentrylist->cbegin(); reit != regentrylist->cend(); ++ reit){
        const RegEntry* re = *reit;

        if(std::find_if(re->cbegin(), re->cend(), [](const RegVar* rv){
                         return !(rv->eflags() & RegEFlag::CO_HIDE); }) == re->cend()){
            continue;
        }

        out << QStringLiteral("#define %1_ENTRY_H%2_%3 &%1->list[%4]")
               .arg(m_odName, QString::number(static_cast<uint>(re->index()), 16).toUpper(),
               RegUtils::makeName(re->name(), m_syntaxType))
               .arg(list_index)
            << "\n";

        list_index ++;
    }

    out << "\n\n";

    return true;
}

bool RegListCoExporter::exportCoC(const QString& filename, const RegEntryList* regentrylist)
{
    QFile file(filename);

    if(!file.open(QIODevice::WriteOnly)) return false;

    QTextStream out_stream(&file);

    QFileInfo fileinfo(file);

#if defined(DEBUG_OUTPUT) && DEBUG_OUTPUT == 1
    Q_UNUSED(out_stream)
    QDebug out = qDebug();
#else
    QTextStream& out = out_stream;
#endif

    QString co_h_name = fileinfo.fileName().replace(".c", ".h");

    // header
    out << "#define OD_DEFINITION\n"
        << "#include \"301/CO_ODinterface.h\"\n"
        << "#include \"" << co_h_name <<  "\"\n"
        << "\n"
        << "#if CO_VERSION_MAJOR < 4\n"
        << "#error This Object dictionary is compatible with CANopenNode V4.0 and above!\n"
        << "#endif\n"
        << "\n\n";

    if(!m_dataFileName.isEmpty()){
        out << "#include \"" << QFileInfo(m_dataFileName).fileName() << "\"\n\n";
    }

    out << "// user code begin\n"
        << m_userCodeCOc
        << "\n// user code end\n\n";

    bool res = true;

    res &= writeAllOdObjConstDefs(out_stream, regentrylist);
    res &= writeOd(out_stream, regentrylist);


    // footer

    // Files closed in dtors, but, i want to do it manually.
    file.close();

    return res;
}

bool RegListCoExporter::writeAllOdObjConstDefs(QTextStream& out_stream, const RegEntryList* regentrylist)
{
#if defined(DEBUG_OUTPUT) && DEBUG_OUTPUT == 1
    Q_UNUSED(out_stream)
    QDebug out = qDebug();
#else
    QTextStream& out = out_stream;
#endif

    out << "// All OD objects (constant definitions)\n";

    out << "typedef struct {\n";

    for(auto reit = regentrylist->cbegin(); reit != regentrylist->cend(); ++ reit){
        const RegEntry* re = *reit;

        if(std::find_if(re->cbegin(), re->cend(), [](const RegVar* rv){
                         return !(rv->eflags() & RegEFlag::CO_HIDE); }) == re->cend()){
            continue;
        }

        out << QStringLiteral("    %1 %2;")
               .arg(getOdEntryTypeStr(re->type()), getOdEntryFieldDecl(re))
            << "\n";
    }

    out << QStringLiteral("} %1Objs_t;\n\n").arg(m_odName);

    out << QStringLiteral("static CO_PROGMEM %1Objs_t %1Objs = {\n").arg(m_odName);

    bool firstEntry = true;

    for(auto reit = regentrylist->cbegin(); reit != regentrylist->cend(); ++ reit){
        const RegEntry* re = *reit;

        if(std::find_if(re->cbegin(), re->cend(), [](const RegVar* rv){
                         return !(rv->eflags() & RegEFlag::CO_HIDE); }) == re->cend()){
            continue;
        }

        if(!firstEntry){
            out << ",\n";
        }
        firstEntry = false;

        out << QStringLiteral(".%1 = {")
               .arg(getOdEntryFieldName(re))
            << "\n";

        if(!writeOdObjConstDef(out_stream, re)) return false;

        out << "}";
    }

    out << "\n};\n";

    return true;
}

bool RegListCoExporter::writeOdObjConstDef(QTextStream& out_stream, const RegEntry* re)
{
    switch(re->type()){
    case ObjectType::VAR:
        if(!writeOdVarConstDef(out_stream, re)) return false;
        break;
    case ObjectType::ARR:
        if(!writeOdArrConstDef(out_stream, re)) return false;
        break;
    case ObjectType::REC:
        if(!writeOdRecConstDef(out_stream, re)) return false;
        break;
    }

    return true;
}

bool RegListCoExporter::writeOdVarConstDef(QTextStream& out_stream, const RegEntry* re)
{
#if defined(DEBUG_OUTPUT) && DEBUG_OUTPUT == 1
    Q_UNUSED(out_stream)
    QDebug out = qDebug();
#else
    QTextStream& out = out_stream;
#endif

    for(auto rvit = re->cbegin(); rvit != re->cend(); ++ rvit){
        const RegVar* rv = *rvit;

        if(rv->eflags() & RegEFlag::CO_HIDE){
            continue;
        }

        QString data_str;
        if(re->type() != ObjectType::ARR || rv->subIndex() == 0){
            data_str = RegUtils::getVarMem(m_dataName, re, rv, 0, m_entryNameMap, m_varNameMap, m_syntaxType);
        }else{
            data_str = RegUtils::getArrMem(m_dataName, re, rv, 0, m_entryNameMap, m_varNameMap, m_syntaxType);
        }

        uint dataSize = RegTypes::sizeBytes(rv->dataType());

        co_attributes_t attrs = RegTypes::eflagsToCoAttributes(rv->eflags());
        if(dataSize > 1) attrs |= COAttribute::MB;
        QString attrs_str = RegTypes::getNames(attrs, RegTypes::coAttributeFullName).join(" | ");

        out << QStringLiteral("    .dataOrig = &%1,")
               .arg(data_str)
            << "\n";

        out << QStringLiteral("    .attribute = %1,")
               .arg(attrs_str)
            << "\n";

        out << QStringLiteral("    .dataLength = %1")
               .arg(dataSize)
            << "\n";
    }

    return true;
}

bool RegListCoExporter::writeOdRecConstDef(QTextStream& out_stream, const RegEntry* re)
{
#if defined(DEBUG_OUTPUT) && DEBUG_OUTPUT == 1
    Q_UNUSED(out_stream)
    QDebug out = qDebug();
#else
    QTextStream& out = out_stream;
#endif

    bool firstVar = true;

    for(auto rvit = re->cbegin(); rvit != re->cend(); ++ rvit){
        const RegVar* rv = *rvit;

        if(rv->eflags() & RegEFlag::CO_HIDE){
            continue;
        }

        if(!firstVar){
            out << ",\n";
        }
        firstVar = false;

        out << "    {\n";

        QString data_str;
        if(re->type() != ObjectType::ARR || rv->subIndex() == 0){
            data_str = RegUtils::getVarMem(m_dataName, re, rv, 0, m_entryNameMap, m_varNameMap, m_syntaxType);
        }else{
            data_str = RegUtils::getArrMem(m_dataName, re, rv, 0, m_entryNameMap, m_varNameMap, m_syntaxType);
        }

        uint dataSize = RegTypes::sizeBytes(rv->dataType());

        co_attributes_t attrs = RegTypes::eflagsToCoAttributes(rv->eflags());
        if(dataSize > 1) attrs |= COAttribute::MB;
        QString attrs_str = RegTypes::getNames(attrs, RegTypes::coAttributeFullName).join(" | ");

        out << QStringLiteral("    .dataOrig = &%1,")
               .arg(data_str)
            << "\n";

        out << QStringLiteral("    .subIndex = %1,")
               .arg(static_cast<uint>(rv->subIndex()))
            << "\n";

        out << QStringLiteral("    .attribute = %1,")
               .arg(attrs_str)
            << "\n";

        out << QStringLiteral("    .dataLength = %1")
               .arg(dataSize)
            << "\n";

        out << "    }";
    }
    out << "\n";

    return true;
}

bool RegListCoExporter::writeOdArrConstDef(QTextStream& out_stream, const RegEntry* re)
{
#if defined(DEBUG_OUTPUT) && DEBUG_OUTPUT == 1
    Q_UNUSED(out_stream)
    QDebug out = qDebug();
#else
    QTextStream& out = out_stream;
#endif

    //const RegVar* rv0;
    QString data_str0;
    QString data_str;
    //const RegVar* rvarr;
    co_attributes_t attrs0 = COAttribute::NONE;
    co_attributes_t attrs = COAttribute::NONE;
    uint dataSize = 0;
    QString dataTypeStr = 0;

    for(auto rvit = re->cbegin(); rvit != re->cend(); ++ rvit){
        const RegVar* rv = *rvit;

        QString cur_data_str;
        if(re->type() != ObjectType::ARR || rv->subIndex() == 0){
            cur_data_str = RegUtils::getVarMem(m_dataName, re, rv, 0, m_entryNameMap, m_varNameMap, m_syntaxType);
        }else{
            cur_data_str = RegUtils::getArrMem(m_dataName, re, rv, 0, m_entryNameMap, m_varNameMap, m_syntaxType);
        }

        uint cur_dataSize = RegTypes::sizeBytes(rv->dataType());

        co_attributes_t cur_attrs = RegTypes::eflagsToCoAttributes(rv->eflags());
        if(cur_dataSize > 1) cur_attrs |= COAttribute::MB;


        if(rv->subIndex() == 0x0){
            data_str0 = cur_data_str;
            attrs0 = cur_attrs;
            //rv0 = rv;
        }else{
            data_str = cur_data_str;
            attrs = cur_attrs;
            dataSize = cur_dataSize;
            dataTypeStr = RegTypes::varDataTypeStr(rv->dataType());
            //rvarr = rv;
            break;
        }
    }

    QString attrs_str0 = RegTypes::getNames(attrs0, RegTypes::coAttributeFullName).join(" | ");
    QString attrs_str = RegTypes::getNames(attrs, RegTypes::coAttributeFullName).join(" | ");

    out << QStringLiteral("    .dataOrig0 = &%1,")
           .arg(data_str0)
        << "\n";
    out << QStringLiteral("    .dataOrig = &%1,")
           .arg(data_str)
        << "\n";
    out << QStringLiteral("    .attribute0 = %1,")
           .arg(attrs_str0)
        << "\n";
    out << QStringLiteral("    .attribute = %1,")
           .arg(attrs_str)
        << "\n";
    out << QStringLiteral("    .dataElementLength = %1,")
           .arg(dataSize)
        << "\n";
    out << QStringLiteral("    .dataElementSizeof = sizeof(%1)")
           .arg(dataTypeStr)
        << "\n";

    return true;
}

bool RegListCoExporter::writeOd(QTextStream& out_stream, const RegEntryList* regentrylist)
{
#if defined(DEBUG_OUTPUT) && DEBUG_OUTPUT == 1
    Q_UNUSED(out_stream)
    QDebug out = qDebug();
#else
    QTextStream& out = out_stream;
#endif

    out << "// Object dictionary\n";
    out << QStringLiteral("static %1_ATTR_OD OD_entry_t %1List[] = {\n").arg(m_odName);

    for(auto reit = regentrylist->cbegin(); reit != regentrylist->cend(); ++ reit){
        const RegEntry* re = *reit;

        if(std::find_if(re->cbegin(), re->cend(), [](const RegVar* rv){
                         return !(rv->eflags() & RegEFlag::CO_HIDE); }) == re->cend()){
            continue;
        }

        uint count = 0;
        if(re->type() == ObjectType::ARR){
            count = re->countAll();
        }else{
            std::for_each(re->cbegin(), re->cend(), [&count](const RegVar* rv){
                if(!(rv->eflags() & RegEFlag::CO_HIDE)){
                    count += rv->count();
                }
            });
        }

        out << QStringLiteral("    {0x%2, 0x%3, %4, &%1Objs.%5, NULL},")
               .arg(m_odName)
               .arg(static_cast<uint>(re->index()), 0, 16)
               .arg(count, 2, 16, QChar('0'))
               .arg(getOdObjectTypeStr(re->type()), getOdEntryFieldName(re))
            << "\n";
    }
    out << "    {0x0000, 0x00, 0, NULL, NULL}\n"
        << "};\n"
        << "\n"
        << QStringLiteral("static OD_t _%1 = {\n").arg(m_odName)
        << QStringLiteral("    (sizeof(%1List) / sizeof(%1List[0])) - 1,\n").arg(m_odName)
        << QStringLiteral("    &%1List[0]\n").arg(m_odName)
        << "};\n"
        << "\n"
        << QStringLiteral("OD_t *%1 = &_%1;\n").arg(m_odName)
        << "\n\n";

    return true;
}

QString RegListCoExporter::getOdObjectTypeStr(ObjectType objType) const
{
    switch(objType){
    case ObjectType::VAR:
        return QStringLiteral("ODT_VAR");
    case ObjectType::ARR:
        return QStringLiteral("ODT_ARR");
    case ObjectType::REC:
        return QStringLiteral("ODT_REC");
    }
    return QStringLiteral("#error Unknown type!");
}

QString RegListCoExporter::getOdEntryTypeStr(ObjectType objType) const
{
    switch(objType){
    case ObjectType::VAR:
        return QStringLiteral("OD_obj_var_t");
    case ObjectType::ARR:
        return QStringLiteral("OD_obj_array_t");
    case ObjectType::REC:
        return QStringLiteral("OD_obj_record_t");
    }
    return QStringLiteral("#error Unknown type!");
}

QString RegListCoExporter::getOdEntryFieldName(const RegEntry* re) const
{
    return QStringLiteral("o_%2_%3")
            .arg(QString::number(static_cast<uint>(re->index()), 16).toUpper(),
                 RegUtils::makeName(re->name(), m_syntaxType));
                 //RegUtils::getEntryName(re, m_entryNameMap, m_syntaxType));
}

QString RegListCoExporter::getOdEntryFieldDecl(const RegEntry* re) const
{
    QString name = getOdEntryFieldName(re);
    if(re->type() == ObjectType::REC){
        name = QStringLiteral("%1[%2]")
               .arg(name)
               .arg(re->count());
    }
    return name;
}
