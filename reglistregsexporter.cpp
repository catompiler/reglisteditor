#include "reglistregsexporter.h"
#include <algorithm>
#include <QFile>
#include <QFileInfo>
#include <QDir>
#include <QIODevice>
#include <QTextStream>
#include <QSet>
#include "regentry.h"
#include "regvar.h"
#include "regtypes.h"
#include "regutils.h"
#include <QDebug>


#define DEBUG_OUTPUT 0


RegListRegsExporter::RegListRegsExporter(QObject *parent)
    : RegListExporter{parent}
{
}

RegListRegsExporter::~RegListRegsExporter()
{
}

bool RegListRegsExporter::doExport(const QString& filename, const RegEntryList* regentrylist)
{
    QFileInfo regs_fi(filename);
    QDir regs_dir = regs_fi.dir();

    QString baseName = regs_fi.baseName();
    QString data_name = baseName + "_data";
    QString data_name_c = data_name + ".c";
    QString data_name_h = data_name + ".h";

    QString ids_filename = regs_dir.filePath(baseName + "_ids.h");
    QString data_filename_c = regs_dir.filePath(data_name_c);
    QString data_filename_h = regs_dir.filePath(data_name_h);

    m_reg_id_names.clear();
    m_reg_data_names.clear();

    if(!exportRegIds(ids_filename, regentrylist)) return false;
    if(!exportRegDataDecl(data_filename_h, regentrylist)) return false;
    if(!exportRegData(data_filename_c, regentrylist)) return false;
    if(!exportRegList(filename, regentrylist)) return false;

    m_reg_id_names.clear();
    m_reg_data_names.clear();

    return true;
}

bool RegListRegsExporter::exportRegIds(const QString& filename, const RegEntryList* regentrylist)
{
    QFile file(filename);

    if(!file.open(QIODevice::WriteOnly)) return false;

    QFileInfo fileinfo(file);

#if defined(DEBUG_OUTPUT) && DEBUG_OUTPUT == 1
    QDebug out = qDebug();
#else
    QTextStream out(&file);
#endif

    QString reg_list_name = fileinfo.fileName().replace(QChar('.'), QChar('_'));
    QString header_guard_name = reg_list_name.toUpper();

    // header
    out << "#ifndef " << header_guard_name << "\n"
        << "#define " << header_guard_name << "\n"
        << "\n\n"
        << "// THIS FILE IS GENERATED AUTOMATICALLY!\n"
        << "// DO NOT EDIT THIS FILE!\n"
        << "\n\n";

    for(auto reit = regentrylist->cbegin(); reit != regentrylist->cend(); ++ reit){
        const RegEntry* re = *reit;

        for(auto rvit = re->cbegin(); rvit != re->cend(); ++ rvit){
            const RegVar* rv = *rvit;

            QString regIdStr = makeRegIdName(re, rv);
            reg_fullindex_t id = RegUtils::makeFullIndex(re->index(), rv->subIndex());

            out << QString("#define %1 %2 /* %6 */")
                   .arg(regIdStr,
                        idToStr(id),
                        rv->description().simplified())
                << "\n";

            //out << regId;

            m_reg_id_names.insert(id, regIdStr);
        }
    }

    // footer
    out << "\n#endif /* " << header_guard_name << " */\n";

    // Files closed in dtors, but, i want to do it manually.
    file.close();

    return true;
}

bool RegListRegsExporter::exportRegList(const QString& filename, const RegEntryList* regentrylist)
{
    QFile file(filename);

    if(!file.open(QIODevice::WriteOnly)) return false;

    QFileInfo fileinfo(file);

#if defined(DEBUG_OUTPUT) && DEBUG_OUTPUT == 1
    QDebug out = qDebug();
#else
    QTextStream out(&file);
#endif

    QString reg_list_name = fileinfo.fileName().replace(QChar('.'), QChar('_'));
    QString header_guard_name = reg_list_name.toUpper();

    // header
    out << "#ifndef " << header_guard_name << "\n"
        << "#define " << header_guard_name << "\n"
        << "\n\n"
        << "// THIS FILE IS GENERATED AUTOMATICALLY!\n"
        << "// DO NOT EDIT THIS FILE!\n"
        << "\n\n";

    out << "REGS_BEGIN(REG_ARRAY_NAME)\n\n";

    for(auto reit = regentrylist->cbegin(); reit != regentrylist->cend(); ++ reit){
        const RegEntry* re = *reit;

        for(auto rvit = re->cbegin(); rvit != re->cend(); ++ rvit){
            const RegVar* rv = *rvit;

            QString regIdStr = makeRegIdName(re, rv);

            reg_fullindex_t base_id = RegUtils::makeFullIndex(rv->baseIndex(), rv->baseSubIndex());
            QString baseIdStr;
            auto it_base = m_reg_id_names.find(base_id);
            if(it_base != m_reg_id_names.end()){
                baseIdStr = it_base.value();
            }else{
                baseIdStr = idToStr(base_id);
            }

            QString data_str = rv->memAddr();

            if(data_str.isEmpty()){
                reg_fullindex_t full_id = RegUtils::makeFullIndex(re->index(), rv->subIndex());
                auto it_data = m_reg_data_names.find(full_id);
                if(it_data != m_reg_data_names.end()){
                    data_str = it_data.value();
                }/*else{
                    data_str = "dummy";
                }*/
            }

            out << QString("REG(%1, %2, %3, %4, %5) /* %6 */")
                   .arg(regIdStr,
                        data_str,
                        regDataTypeStr(rv->dataType()),
                        flagsToStr(rv->flags()),
                        baseIdStr,
                        rv->description().simplified())
                << "\n";

            //out << regId;
        }
    }

    out << "\nREGS_END()\n\n";

    // footer
    out << "\n#endif /* " << header_guard_name << " */\n";

    // Files closed in dtors, but, i want to do it manually.
    file.close();

    return true;
}

bool RegListRegsExporter::exportRegDataDecl(const QString& filename, const RegEntryList* regentrylist)
{
    QFile file(filename);

    if(!file.open(QIODevice::WriteOnly)) return false;

    QFileInfo fileinfo(file);

#if defined(DEBUG_OUTPUT) && DEBUG_OUTPUT == 1
    QDebug out = qDebug();
#else
    QTextStream out(&file);
#endif

    QString struct_name;
    QString struct_type;
    QString base_name = fileinfo.baseName();

    auto write_struct_begin = [this, &out, &base_name, &struct_name, &struct_type](const RegEntry* re = nullptr){
        struct_name = makeDataStructName(base_name, re);
        struct_type = makeDataStructTypeName(struct_name);

        out << "struct " << struct_type << " {\n";
    };

    auto write_struct_end = [&out, &struct_name, &struct_type](){
        out << "};\n";
        out << QStringLiteral("extern struct %1 %2;").arg(struct_type, struct_name);
        out << "\n\n";
    };

    QString reg_list_name = fileinfo.fileName().replace(QChar('.'), QChar('_'));
    QString header_guard_name = reg_list_name.toUpper();

    // header
    out << "#ifndef " << header_guard_name << "\n"
        << "#define " << header_guard_name << "\n"
        << "\n\n"
        << "// THIS FILE IS GENERATED AUTOMATICALLY!\n"
        << "// DO NOT EDIT THIS FILE!\n"
        << "\n\n";

    if(m_mapType == RegUtils::NameMapping::WITHIN_ALL){
        write_struct_begin();
    }

    for(auto reit = regentrylist->cbegin(); reit != regentrylist->cend(); ++ reit){
        const RegEntry* re = *reit;

        bool hasEmpty = std::any_of(re->cbegin(), re->cend(), [](const RegVar* rv){
            return rv->memAddr().isEmpty();
        });

        if(!hasEmpty) continue;

        if(m_mapType == RegUtils::NameMapping::WITHIN_ENTRY){
            write_struct_begin(re);
        }

        for(auto rvit = re->cbegin(); rvit != re->cend(); ++ rvit){
            const RegVar* rv = *rvit;

            if(!rv->memAddr().isEmpty()){
                continue;
            }

            QString fieldName = RegUtils::getVarName(re, rv, m_varNameMap);
            //reg_fullindex_t id = RegUtils::makeFullIndex(re->index(), rv->subIndex());

            out << QStringLiteral("    %1 %2; /* %3 */")
                   .arg(RegTypes::varDataTypeStr(rv->dataType()),
                        fieldName,
                        rv->description().simplified())
                << "\n";
        }

        if(m_mapType == RegUtils::NameMapping::WITHIN_ENTRY){
            write_struct_end();
        }
    }

    if(m_mapType == RegUtils::NameMapping::WITHIN_ALL){
        write_struct_end();
    }

    // footer
    out << "\n#endif /* " << header_guard_name << " */\n";

    // Files closed in dtors, but, i want to do it manually.
    file.close();

    return true;
}

bool RegListRegsExporter::exportRegData(const QString& filename, const RegEntryList* regentrylist)
{
    QFile file(filename);

    if(!file.open(QIODevice::WriteOnly)) return false;

    QFileInfo fileinfo(file);

#if defined(DEBUG_OUTPUT) && DEBUG_OUTPUT == 1
    QDebug out = qDebug();
#else
    QTextStream out(&file);
#endif

    QString base_name = fileinfo.baseName();

    QString struct_name;

    auto write_struct_begin = [this, &out, base_name, &struct_name](const RegEntry* re = nullptr){
        struct_name = makeDataStructName(base_name, re);
        QString struct_type = makeDataStructTypeName(struct_name);

        out << "struct " << struct_type << " " << struct_name << " = {\n";
    };

    auto write_struct_end = [&out](){
        out << "\n};\n\n";
    };

    QString header_name = fileinfo.fileName().replace(QStringLiteral(".c"), QStringLiteral(".h"));

    // header
    out << "#include \"" << header_name << "\"\n"
        << "\n\n"
        << "// THIS FILE IS GENERATED AUTOMATICALLY!\n"
        << "// DO NOT EDIT THIS FILE!\n"
        << "\n\n";

    if(m_mapType == RegUtils::NameMapping::WITHIN_ALL){
        write_struct_begin();
    }

    for(auto reit = regentrylist->cbegin(); reit != regentrylist->cend(); ++ reit){
        const RegEntry* re = *reit;

        bool hasEmpty = std::any_of(re->cbegin(), re->cend(), [](const RegVar* rv){
            return rv->memAddr().isEmpty();
        });

        if(!hasEmpty) continue;

        if(m_mapType == RegUtils::NameMapping::WITHIN_ENTRY){
            write_struct_begin(re);
        }

        bool firstVar = true;

        for(auto rvit = re->cbegin(); rvit != re->cend(); ++ rvit){
            const RegVar* rv = *rvit;

            if(!rv->memAddr().isEmpty()){
                continue;
            }

            if(!firstVar){
                out << ",\n";
            }
            firstVar = false;

            QString fieldName = RegUtils::getVarName(re, rv, m_varNameMap);
            //reg_fullindex_t id = RegUtils::makeFullIndex(re->index(), rv->subIndex());

            out << QStringLiteral("    .%1 = %2 /* %3 */")
                   .arg(fieldName,
                        rv->defaultValue().toString(),
                        rv->description().simplified());

            m_reg_data_names.insert(
                            RegUtils::makeFullIndex(re->index(), rv->subIndex()),
                            memName(struct_name, fieldName)
                        );
        }

        if(m_mapType == RegUtils::NameMapping::WITHIN_ENTRY){
            write_struct_end();
        }
    }

    if(m_mapType == RegUtils::NameMapping::WITHIN_ALL){
        write_struct_end();
    }

    // footer

    // Files closed in dtors, but, i want to do it manually.
    file.close();

    return true;
}

QString RegListRegsExporter::makeRegName(const RegEntry* re, const RegVar* rv) const
{
    if(m_mapType == RegUtils::NameMapping::WITHIN_ENTRY){
        QString entry_name = RegUtils::getEntryName(re, m_entryNameMap);
        QString var_name = RegUtils::getVarName(re, rv, m_varNameMap);

        return QString("%1_%2").arg(entry_name, var_name);
    }else if(m_mapType == RegUtils::NameMapping::WITHIN_ALL){
        QString var_name = RegUtils::getVarName(re, rv, m_varNameMap);

        return var_name;
    }

    return QString("%1_%2").arg(re->name(), rv->name());
}

QString RegListRegsExporter::makeRegIdName(const RegEntry* re, const RegVar* rv) const
{
    return QString("REG_ID_%1").arg(makeRegName(re, rv).toUpper());
}

QString RegListRegsExporter::makeDataStructName(const QString& baseName, const RegEntry* re) const
{
    if(m_mapType == RegUtils::NameMapping::WITHIN_ENTRY){
        if(re != nullptr){
            QString entry_name = RegUtils::getEntryName(re, m_entryNameMap);
            return QString("%1_%2").arg(baseName, entry_name);
        }
    }/*else if(m_mapType == RegUtils::NameMapping::WITHIN_ALL){
        return baseName;
    }*/
    return baseName;
}

QString RegListRegsExporter::makeDataStructTypeName(const QString& name) const
{
    return QString("_S_%1").arg(name);
}

RegListRegsExporter& RegListRegsExporter::setNameMapping(RegUtils::NameMapping::Value mapType)
{
    m_mapType = mapType;

    return *this;
}

RegListRegsExporter& RegListRegsExporter::setEntryNameMap(const RegUtils::EntryNameMap* entryNameMap)
{
    m_entryNameMap = entryNameMap;

    return *this;
}

RegListRegsExporter& RegListRegsExporter::setVarNameMap(const RegUtils::VarNameMap* varNameMap)
{
    m_varNameMap = varNameMap;

    return *this;
}

QString RegListRegsExporter::regDataTypeStr(DataType type) const
{
    QString type_name = RegTypes::dataTypeStr(static_cast<DataType>(type));
    if(!type_name.isEmpty()) return QString("REG_TYPE_") + type_name;
    return QString("0x%1").arg(static_cast<uint>(type));
}

QString RegListRegsExporter::flagToStr(uint flag) const
{
    QString flag_name = RegTypes::flagName(static_cast<RegFlag::Value>(flag));
    if(!flag_name.isEmpty()) return QString("REG_FLAG_") + flag_name;
    return QString("0x%1").arg(flag);
}

QString RegListRegsExporter::flagsToStr(uint flags) const
{
    QString flags_str;

    uint flag = 0x1;

    while(flags != 0){
        if(flags & 0x1){
            if(!flags_str.isEmpty()){
                flags_str += " | ";
            }
            flags_str = flagToStr(flag);
        }

        flag <<= 1;
        flags >>= 1;
    }

    if(flags_str.isEmpty()){
        flags_str = flagToStr(RegFlag::NONE);
    }

    return flags_str;
}

QString RegListRegsExporter::idToStr(uint id) const
{
    return QString("0x%1").arg(id, 6, 16, QChar('0'));
}

QString RegListRegsExporter::memName(const QString& group, const QString& var) const
{
    return QStringLiteral("%1.%2").arg(group).arg(var);
}
