#include "reglistregsexporter.h"
#include <algorithm>
#include <QFile>
#include <QFileInfo>
#include <QDir>
#include <QIODevice>
#include <QTextStream>
#include <QSet>
#include "regentry.h"
#include "regvar.h"
#include "regtypes.h"
#include "regutils.h"
#include <QDebug>



RegListRegsExporter::RegListRegsExporter(QObject *parent)
    : RegListExporter{parent}
{
}

RegListRegsExporter::~RegListRegsExporter()
{
}


bool RegListRegsExporter::doExport(const QString& filename, const RegEntryList* regentrylist)
{
    QFileInfo regs_fi(filename);
    QDir regs_dir = regs_fi.dir();

    QString baseName = regs_fi.baseName();
    QString data_name = baseName + "_data";
    QString data_name_c = data_name + ".c";
    QString data_name_h = data_name + ".h";

    QString ids_filename = regs_dir.filePath(baseName + "_ids.h");
    QString data_filename_c = regs_dir.filePath(data_name_c);
    QString data_filename_h = regs_dir.filePath(data_name_h);

    auto reglist = genRegList(regentrylist);
    fixEqualNames(reglist);

    auto regdata = genAndFixRegData(reglist, data_name);

    if(!exportRegList(filename, reglist)) return false;
    if(!exportRegIds(ids_filename, reglist)) return false;
    if(!exportRegData(data_filename_c, regdata)) return false;
    if(!exportRegDataDecl(data_filename_h, regdata)) return false;

    return true;
}

bool RegListRegsExporter::exportRegList(const QString& filename, const RegList& reglist) const
{
    QFile file(filename);

    if(!file.open(QIODevice::WriteOnly)) return false;

    QFileInfo fileinfo(file);
    QTextStream out(&file);

    QString reg_list_name = fileinfo.fileName().replace(QChar('.'), QChar('_'));
    QString header_guard_name = reg_list_name.toUpper();

    // header
    out << "#ifndef " << header_guard_name << "\n"
        << "#define " << header_guard_name << "\n"
        << "\n\n"
        << "// THIS FILE IS GENERATED AUTOMATICALLY!\n"
        << "// DO NOT EDIT THIS FILE!\n"
        << "\n\n";

    out << "REGS_BEGIN(REG_ARRAY_NAME)\n\n";

    for(auto it = reglist.cbegin(); it != reglist.cend(); ++ it){
        const Reg& reg = it.value();

        QString base_id_name;
        auto base_it = reglist.find(reg.base_id);
        if(base_it != reglist.cend()){
            base_id_name = base_it->id_name;
        }else{
            base_id_name = QString("REG_ID_NONE");
        }

        out << QString("REG(%1, %2, %3, %4, %5) /* %6 */\n")
               .arg(makeRegIdName(reg.id_name))
               .arg(reg.data)
               .arg(dataTypeToStr(reg.datatype))
               .arg(flagsToStr(reg.flags))
               .arg(base_id_name)
               .arg(reg.comment);
    }

    out << "\nREGS_END()\n\n";

    // footer
    out << "\n#endif /* " << header_guard_name << " */\n";

    // Files closed in dtors, but, i want to do it manually.
    file.close();

    return true;
}

bool RegListRegsExporter::exportRegIds(const QString& filename, const RegList& reglist) const
{
    QFile file(filename);

    if(!file.open(QIODevice::WriteOnly)) return false;

    QFileInfo fileinfo(file);
    QTextStream out(&file);

    QString reg_list_name = fileinfo.fileName().replace(QChar('.'), QChar('_'));
    QString header_guard_name = reg_list_name.toUpper();

    // header
    out << "#ifndef " << header_guard_name << "\n"
        << "#define " << header_guard_name << "\n"
        << "\n\n"
        << "// THIS FILE IS GENERATED AUTOMATICALLY!\n"
        << "// DO NOT EDIT THIS FILE!\n"
        << "\n\n";

    for(auto it = reglist.cbegin(); it != reglist.cend(); ++ it){
        const uint& id = it.key();
        const Reg& reg = it.value();

        out << QString("#define %1 %2 /* %6 */\n")
               .arg(makeRegIdName(reg.id_name))
               .arg(idToStr(id))
               .arg(reg.comment);
    }

    // footer
    out << "\n#endif /* " << header_guard_name << " */\n";

    // Files closed in dtors, but, i want to do it manually.
    file.close();

    return true;
}

bool RegListRegsExporter::exportRegData(const QString& filename, const RegData& regdata) const
{
    QFile file(filename);

    if(!file.open(QIODevice::WriteOnly)) return false;

    QFileInfo fileinfo(file);
    QTextStream out(&file);

    // header
    out << "\n\n"
        << "// THIS FILE IS GENERATED AUTOMATICALLY!\n"
        << "// DO NOT EDIT THIS FILE!\n"
        << "\n\n";

    out << "struct _S_" << regdata.name << " " << regdata.name << " = {\n";

    bool beg = true;
    for(const auto& field: regdata.fields){
        if(!beg){
            out << ",\n";
        }
        if(field.count > 1){
            out << "    {\n     ";
            for(uint i = 0; i < field.count; i ++){
                if(i != 0) out << ", ";
                out << field.defval;
            }
            out << "\n    }";
        }else{
            out << "    " << field.defval;
        }
        beg = false;
    }

    out << "\n};\n";

    // footer
    //

    // Files closed in dtors, but, i want to do it manually.
    file.close();

    return true;
}

bool RegListRegsExporter::exportRegDataDecl(const QString& filename, const RegData& regdata) const
{
    QFile file(filename);

    if(!file.open(QIODevice::WriteOnly)) return false;

    QFileInfo fileinfo(file);
    QTextStream out(&file);

    QString reg_data_name = fileinfo.fileName().replace(QChar('.'), QChar('_'));
    QString header_guard_name = reg_data_name.toUpper();

    // header
    out << "#ifndef " << header_guard_name << "\n"
        << "#define " << header_guard_name << "\n"
        << "\n\n"
        << "// THIS FILE IS GENERATED AUTOMATICALLY!\n"
        << "// DO NOT EDIT THIS FILE!\n"
        << "\n\n";

    out << "struct _S_" << regdata.name << " {\n";

    for(const auto& field: regdata.fields){

        if(field.count > 1){
            out << "    " << field.datatype << " " << field.name << "[" << field.count << "];\n";
        }else{
            out << "    " << field.datatype << " " << field.name << ";\n";
        }
    }

    out << "};\n";

    out << "\nextern struct _S_" << regdata.name << " " << regdata.name << ";\n";

    // footer
    out << "\n#endif /* " << header_guard_name << " */\n";

    // Files closed in dtors, but, i want to do it manually.
    file.close();

    return true;
}

QString RegListRegsExporter::regDataVarTypeStr(DataType type) const
{
    switch(type){
    case DataType::I32:
        return QString("reg_i32_t");
    case DataType::I16:
        return QString("reg_i16_t");
    case DataType::I8:
        return QString("reg_i8_t");
    case DataType::U32:
        return QString("reg_u32_t");
    case DataType::U16:
        return QString("reg_u16_t");
    case DataType::U8:
        return QString("reg_u8_t");
    case DataType::IQ24:
        return QString("reg_iq24_t");
    case DataType::IQ15:
        return QString("reg_iq15_t");
    case DataType::IQ7:
        return QString("reg_iq7_t");
    }

    return QString("long");
}

RegListRegsExporter::RegList RegListRegsExporter::genRegList(const RegEntryList* entrylist) const
{
    RegList reglist;

    std::for_each(entrylist->cbegin(), entrylist->cend(), [this, &reglist](const RegEntry* re){

        QString group_name = re->name();

        std::for_each(re->cbegin(), re->cend(), [this, &group_name, re, &reglist](const RegVar* rv){
            if(!(rv->eflags() & static_cast<uint>(RegEFlag::RL_HIDE))){

                QString reg_name = rv->name();

                Reg reg;

                uint id = makeRegId(re->index(), rv->subIndex());

                reg.id_name = makeRegName(group_name.toUpper(), reg_name.toUpper());
                reg.datatype = rv->dataType();
                reg.count = rv->count();
                reg.data = rv->memAddr();
                reg.flags = rv->flags();
                reg.base_id = makeRegId(rv->baseIndex(), rv->baseSubIndex());
                reg.defval = rv->defaultValue().toString();
                reg.comment = rv->description().simplified();

                reglist.insert(id, reg);

                //qDebug() << reg.id_name;
            }
        });
    });

    return reglist;
}

void RegListRegsExporter::fixEqualNames(RegList& reglist) const
{
    QSet<QString> regnames;

    QString new_name;
    uint i;

    for(auto it = reglist.begin(); it != reglist.end(); ++ it){
        if(regnames.contains(it->id_name)){
            //qDebug() << "Already exist" << it->id_name;
            i = 1;
            do{
                new_name = QString("%1_%2").arg(it->id_name).arg(i ++);
            }while(regnames.contains(new_name));
            it->id_name = new_name;
            //qDebug() << "new name:" << new_name;
        }
        regnames.insert(it->id_name);
    }
}

RegListRegsExporter::RegData RegListRegsExporter::genAndFixRegData(RegList& reglist, const QString& name) const
{
    RegData regdata;

    regdata.name = name;

    for(auto it = reglist.begin(); it != reglist.end(); ++ it){
        if(it->data.isEmpty()){
            RegDataField field;
            field.datatype = regDataVarTypeStr(it->datatype);
            field.count = it->count;
            field.name = it->id_name.toLower();
            field.defval = it->defval;

            it->data = QString("%1.%2").arg(regdata.name).arg(field.name);

            //qDebug() << it->data;

            regdata.fields.append(field);
        }
    }

    return regdata;
}

uint RegListRegsExporter::makeRegId(reg_index_t index, reg_subindex_t subindex) const
{
    return ((uint)index << 8) | ((uint)subindex & 0xff);
}

QString RegListRegsExporter::makeRegName(const QString& group_name, const QString& reg_name) const
{
    return QString("%1_%2").arg(group_name).arg(reg_name);
}

QString RegListRegsExporter::makeRegIdName(const QString& reg_name) const
{
    return QString("REG_ID_%1").arg(reg_name);
}

QString RegListRegsExporter::memName(const QString& mem, const QString& group, const QString& var) const
{
    if(!mem.isEmpty()) return mem;

    return QString("%1.%2").arg(group).arg(var);
}

QString RegListRegsExporter::dataTypeToStr(DataType type) const
{
    QString type_name = RegTypes::dataTypeStr(static_cast<DataType>(type));
    if(!type_name.isEmpty()) return QString("REG_TYPE_") + type_name;
    return QString("0x%1").arg(static_cast<uint>(type));
}

QString RegListRegsExporter::flagToStr(uint flag) const
{
    QString flag_name = RegTypes::flagName(static_cast<RegFlag::Value>(flag));
    if(!flag_name.isEmpty()) return QString("REG_FLAG_") + flag_name;
    return QString("0x%1").arg(flag);
}

QString RegListRegsExporter::flagsToStr(uint flags) const
{
    QString flags_str;

    uint flag = 0x1;

    while(flags != 0){
        if(flags & 0x1){
            if(!flags_str.isEmpty()){
                flags_str += " | ";
            }
            flags_str = flagToStr(flag);
        }

        flag <<= 1;
        flags >>= 1;
    }

    if(flags_str.isEmpty()){
        flags_str = flagToStr(RegFlag::NONE);
    }

    return flags_str;
}

QString RegListRegsExporter::idToStr(uint id) const
{
    return QString("0x%1").arg(id, 6, 16, QChar('0'));
}
