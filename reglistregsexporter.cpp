#include "reglistregsexporter.h"
#include <algorithm>
#include <QFile>
#include <QFileInfo>
#include <QIODevice>
#include <QTextStream>
#include "regentry.h"
#include "regvar.h"
#include "regtypes.h"
#include "regutils.h"



RegListRegsExporter::RegListRegsExporter(QObject *parent)
    : RegListExporter{parent}
{
}

RegListRegsExporter::~RegListRegsExporter()
{
}


bool RegListRegsExporter::doExport(const QString& filename, const RegEntryList* reglist)
{
    QFileInfo regs_fi(filename);
    QString ids_filename = regs_fi.baseName() + "_ids.h";

    if(!exportRegList(filename, reglist)) return false;
    if(!exportRegIds(ids_filename, reglist)) return false;

    return true;
}

bool RegListRegsExporter::exportRegList(const QString& filename, const RegEntryList* reglist) const
{
    QFile file(filename);

    if(!file.open(QIODevice::WriteOnly)) return false;

    QFileInfo fileinfo(file);
    QTextStream out(&file);

    QString reg_list_name = fileinfo.fileName().replace(QChar('.'), QChar('_'));
    QString header_guard_name = reg_list_name.toUpper();

    // header
    out << "#ifndef " << header_guard_name << "\n"
        << "#define " << header_guard_name << "\n"
        << "\n\n"
        << "// THIS FILE IS GENERATED AUTOMATICALLY!\n"
        << "// DO NOT EDIT THIS FILE!\n"
        << "\n"
        << "// Modules for registers\n"
        << "#include \"modules/modules.h\"\n"
        << "\n\n";

    out << "REGS_BEGIN(REG_ARRAY_NAME)\n\n";

    std::for_each(reglist->cbegin(), reglist->cend(), [this, &out](const RegEntry* re){
        QString group_name = re->name().toUpper();

        std::for_each(re->cbegin(), re->cend(), [this, &out, &group_name, re](const RegVar* rv){
            if(!(rv->eflags() & static_cast<uint>(RegEFlag::RL_HIDE))){
                out << QString("REG(REG_ID_%1_%2, %3, %4, %5, %6)\n")
                       .arg(group_name)
                       .arg(rv->name().toUpper())
                       .arg(memName(rv->memAddr(), re->name(), rv->name()))
                       .arg(typeToStr(static_cast<uint>(rv->dataType())))
                       .arg(flagsToStr(static_cast<uint>(rv->flags())))
                       .arg(indexSubIndexToStr(rv->baseIndex(), rv->baseSubIndex()));
            }
        });
    });

    out << "\nREGS_END()\n\n";

    // footer
    out << "\n#endif /* " << header_guard_name << " */\n";

    // Files closed in dtors, but, i want to do it manually.
    file.close();

    return true;
}

bool RegListRegsExporter::exportRegIds(const QString& filename, const RegEntryList* reglist) const
{
    return true;
}

QString RegListRegsExporter::memName(const QString& mem, const QString& group, const QString& var) const
{
    if(!mem.isEmpty()) return mem;

    return QString("%1.%2").arg(group).arg(var);
}

QString RegListRegsExporter::typeToStr(uint type) const
{
    return QString("REG_TYPE_") + RegTypes::dataTypeStr(static_cast<DataType>(type));
}

QString RegListRegsExporter::flagsToStr(uint flags) const
{
    QString flag_str;
    QString flags_str;

    uint flag = 0x1;

    while(flags != 0){
        if(flags & 0x1){
            flag_str = RegTypes::flagFullName(static_cast<RegFlag::Value>(flag));

            if(!flags_str.isEmpty()){
                flags_str += " | ";
            }

            if(!flag_str.isEmpty()){
                flags_str += flag_str;
            }else{
                flags_str += QString::number(flag);
            }
        }
        flag <<= 1;
        flags >>= 1;
    }

    if(flags_str.isEmpty()){
        flags_str = RegTypes::flagFullName(RegFlag::NONE);
    }

    return flags_str;
}

QString RegListRegsExporter::indexSubIndexToStr(uint index, uint subindex) const
{
    return QString("0x%1").arg((index << 8) | (subindex & 0xff), 6, 16, QChar('0'));
}
